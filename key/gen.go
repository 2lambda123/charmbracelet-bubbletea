package main

import (
	"errors"
	"fmt"
	"os"
	"os/exec"
	"sort"
	"strings"
)

const lexFile = "key_parse.l"
const goFile = "key_parse.go"

func main() {
	if err := doMain(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

type seqEntry struct {
	seq  string
	code string
}

func doMain() error {
	l, err := os.ReadFile("key.go")
	if err != nil {
		return err
	}
	lines := strings.Split(string(l), "\n")
	var sequences []seqEntry
	inseq := false
	for _, line := range lines {
		switch {
		case strings.HasPrefix(line, "var sequences"):
			inseq = true
		case strings.HasPrefix(line, "}"):
			inseq = false
		case inseq && strings.Contains(line, "Type:"):
			parts := strings.SplitN(line, ":", 2)
			seq := strings.Trim(strings.TrimSpace(parts[0]), `"`)
			remainder := strings.SplitN(parts[1], "//", 2)
			code := strings.ReplaceAll(strings.TrimSpace(remainder[0]), "},", "}")
			sequences = append(sequences, seqEntry{seq, code})

			if !strings.Contains(code, "Alt: true") {
				sequences = append(sequences, seqEntry{`\x1b` + seq, code + "/*Alt: true*/"})
			}
		}
	}

	// Ensure that the longest sequence(s) appear first. This is needed
	// because the golex engines branches in input order.
	sort.Slice(sequences, func(i, j int) bool {
		return len(sequences[i].seq) > len(sequences[j].seq) ||
			(len(sequences[i].seq) == len(sequences[j].seq) &&
				sequences[i].seq < sequences[j].seq)
	})

	if err := emitLex(sequences); err != nil {
		return err
	}

	_, err = exec.LookPath("golex")
	if err != nil {
		return errors.New("golex not installed?\ninstall with: go install modernc.org/golex@latest")
	}

	cmd := exec.Command("golex", "-o", goFile, lexFile)
	o, err := cmd.CombinedOutput()
	_, _ = os.Stdout.Write(o)
	return err
}

func emitLex(sequences []seqEntry) (resErr error) {
	f, err := os.OpenFile(lexFile, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0666)
	if err != nil {
		return err
	}
	defer func() { resErr = f.Close() }()
	fmt.Fprint(f, prefix)
	for _, entry := range sequences {
		seq := strings.ReplaceAll(entry.seq, `[`, `\[`)
		seq = strings.ReplaceAll(seq, `$`, `\$`)
		seq = strings.ReplaceAll(seq, `^`, `\^`)
		fmt.Fprintln(f, seq)
		fmt.Fprintln(f, "   ktype = Key"+entry.code+".Type")
		if strings.Contains(entry.code, "Alt: true") {
			fmt.Fprintln(f, "   alt = true")
		}
		fmt.Fprintln(f, "   goto key")
		fmt.Fprintln(f)
	}
	fmt.Fprint(f, suffix)
	return nil
}

const prefix = `
%{
// Code generated by key/gen.go. DO NOT EDIT.

package tea

func detectSequence(buf []byte) (ok bool, width int, res Msg) {
   //
   // NB: The remainder of this code was carefully crafted to avoid
   // function calls, bounds checks and and escapes during the escape traversal.
   // When modifying this logic, be careful to inspect the generated
   // assembly (go build -gcflags='-v -S').
   //
   var c byte
   i := uint(0)
   var ktype KeyType
   var alt bool
   var runes []rune
%}
%yyn if i >= uint(len(buf)) { c = 0 } else { c = buf[i] }; i++
%yyc c
%%
  goto yystate1

`

const suffix = `
\x1b\[[\x30-\x3f]*[\x20-\x2f]*[\x40-\x7e]
    return true, int(i-1), unknownCSISequenceMsg(buf[:i-1])

\x20
    ktype = KeySpace
    runes = spaceRunes
    goto key

\x1b\x20
    ktype = KeySpace
    runes = spaceRunes
    alt = true
    goto key

\x1b([\x01-\x1f\x7f]|\n)
    // alt + control char (including alt+escape, but not NUL
    // which will be handled by detectOneMsg()).
    alt = true
    ktype = KeyType(buf[1])
    goto key

[\x01-\x1a\x1c-\x1f\x7f]|\n
    // solitary control char; but NOT single escape or NUL
    // which will be handled by detectOneMsg().
    ktype = KeyType(buf[0])
    goto key

%%
   return false, 0, nil

key:
   return true, int(i-1), KeyMsg(Key{Type: ktype, Alt: alt, Runes: runes})
}
`
